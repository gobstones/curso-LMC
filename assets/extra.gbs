//===============================================================
//===============================================================
//==== LMC Programs
//===============================================================
//===============================================================
// REQUIRES: LMCModel

/* program {
    lmc := loadInput_On_([10,20,30],
           loadProgram_On_(accumulatesInpToOut(),
           emptyLMCWithMemSize_AndWidth_(20, 10)
           ))
    
    return (execute_Program(lmc))
}
 */

//-------------------------------
// LMC programs
//  halt   0  //  add    1  //  sta    3
//            //  sub    2  //  lda    5
//  bra    6  //  brz    7  //  brp    8
//  e_s    9
//-------------------------------
function copyInpToOut()        { return([901, 704, 902, 600])           }
function accumulatesInpToOut() { return([901, 710, 109, 309, 902, 600]) }
//===============================================================
//===============================================================
//==== LMC Board Representation
//===============================================================
//===============================================================
// REQUIRES: GobstonesAmenities
// REQUIRES: GobstonesLists
// REQUIRES: LMCForm
// REQUIRES: LMCMem
// REQUIRES: LMCModel

// program {
//   lmc := loadInput_On_([10,20,30],
//          loadProgram_On_([901, 902],
//          emptyLMCWithMemSize_(20)
//          ))
//   PonerLMC_WithRep_InPlace_( lmc
//                            , lmcRepresentation()
//                            , lmcPlacement())
// }

//----------------------------------------------------------
// LMC's Board Representation 
//----------------------------------------------------------
//type LMCBoardRep is LMCForm(
//      lm       -> (Color, Lista de Números)
//    , pc       -> (Color, Número)
//    , acc      -> (Color, Número)
//    , neg      -> (Color, Número)
//    , inp      -> (Color, Número)
//    , out      -> (Color, Número)
//    , mbs      -> (Color, Número)
//    , bounds   -> (Color, Lista de Números)
//    , wz       -> (Color, Número)
//    , iz       -> (Color, Número)
//    , dz       -> (Color, Número)
//    , contents -> (Color, Número)
//}

//----------------------------------------------------------
// LMC's Board Placement
//----------------------------------------------------------
//type Coord is (Número, Número)
//type LMCBoardPlace is LMCForm(
//      lm       -> Coord               // Relative to bounds
//    , pc       -> Coord               // Relative to bounds
//    , acc      -> Coord               // Relative to bounds
//    , neg      -> Coord               // Relative to bounds
//    , inp      -> (Coord, Dirección)  // Base coord, dir of second coord, relative to bounds
//    , out      -> (Coord, Dirección)  // Base coord, dir of second coord, relative to bounds
//    , mbs      -> (Coord, Número)     // LowerLeft corner, relative to bounds
//    , bounds   -> Coord               // LowerLeft corner, absolute
//    , wz       -> Coord               // Relative to bounds
//    , iz       -> Coord               // Relative to bounds
//    , dz       -> Coord               // Relative to bounds
//    , contents -> Coord               // Current position, relative (ideally, the same of LM)
//}

//----------------------------------------------------------
function lmcRepresentation() {
   /* PURPOSE: describes a LMCForm of type LMCBoardRep, with a representation of an LMC
      PRECONDITIONS: none
  */
  return (LMCForm(lm       <- (Verde, [ 11, 1 ])      // The Little Man representation (Halted, Active)
                , pc       <- (Negro, 10)             // The Program Counter place representation
                , acc      <- (Negro, 11)             // The Accumulator place representation
                , neg      <- (Negro, 12)             // The NEGative flag place representation
                , inp      <- (Negro,  2)             // The INPut place representation
                , out      <- (Negro,  3)             // The OUTput place representation
                , mbs      <- (Negro,  1)             // The MailBoxeS places representation
                , bounds   <- (Rojo , [1,2,3,4,5,6])  // The BOUNDS are walls representation (Vertical, Horizontal, NO, NE, SO, SE)
                , wz       <- (Negro, 20)             // The Working Zone place representation
                , iz       <- (Negro, 21)             // The Instruction Zone place representation
                , dz       <- (Negro, 22)             // The Data Zone place representation
                , contents <- (Azul ,  0)             // The numeric CONTENTS of mailboxes; any number will do
         ))
}

//----------------------------------------------------------
function lmcPlacementForMemWidth_(memWidth) {
   /* PURPOSE: describes a LMCForm of type LMCBoardPlace, with the absolute positions of elements in an LMC
      PRECONDITIONS: none
      OBSERVATION: the lmc final drawing depends on memory shape. 
                   Walls surround the memory Mailboxes tightly.
                   Placement of elements must be according to that, on the base.
                   (Usually, at the base -- see function baseHeight)
                        . /==========\.
                        . |mmmmmmmmmm|.
                        . |mmmmmmmmmm|.  Memory
                        . |mmmmmmmmmm|.
                        . |  l       |.  Base
                        . i  panwid  o.    (Elements -- at the base)
                          \==========/
   */
  Assert(memWidth>=6, "Width too small for this placement -- memWidth must be >=6, for 6 elements")
  elemsOffset := (memWidth-6) div 2 + 1
  width := memWidth + 2 // Place for the 2 walls
  return (LMCForm(lm       <-  (elemsOffset   ,2)         // The Little Man place position
                , pc       <-  (elemsOffset   ,1)         // The Program Counter place position
                , acc      <-  (elemsOffset+ 1,1)         // The Accumulator place position
                , neg      <-  (elemsOffset+ 2,1)         // The NEGative flag place position
                , inp      <- ((             0,1), Oeste) // The INPut place position, and where to continue
                , out      <- ((elemsOffset+10,1), Este)  // The OUTput place position, and where to continue
                , mbs      <- ((             1,3), width) // The MailBoxeS left corner position and width
                , bounds   <-  (             1,0)         // The BOUNDS walls left corner place position (absolute)
                , wz       <-  (elemsOffset+ 3,1)         // The Working Zone place position
                , iz       <-  (elemsOffset+ 4,1)         // The Instruction Zone place position
                , dz       <-  (elemsOffset+ 5,1)         // The Data Zone place position
                , contents <-  (             0,0)         // The origin
         ))
}

function absoluteBASEplace (lmcPlace) { return (displace_From_(bounds(lmcPlace)                                     , contents(lmcPlace))) }
function absoluteLMplace   (lmcPlace) { return (displace_From_(displace_From_(lm (lmcPlace)     , bounds(lmcPlace))), contents(lmcPlace) ) }
function absolutePCplace   (lmcPlace) { return (displace_From_(displace_From_(pc (lmcPlace)     , bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteACCplace  (lmcPlace) { return (displace_From_(displace_From_(acc(lmcPlace)     , bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteNEGplace  (lmcPlace) { return (displace_From_(displace_From_(neg(lmcPlace)     , bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteINPplace  (lmcPlace) { return (displace_From_(displace_From_(fst(inp(lmcPlace)), bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteOUTplace  (lmcPlace) { return (displace_From_(displace_From_(fst(out(lmcPlace)), bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteMBSplace  (lmcPlace) { return (displace_From_(displace_From_(fst(mbs(lmcPlace)), bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteWZplace   (lmcPlace) { return (displace_From_(displace_From_(wz (lmcPlace)     , bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteIZplace   (lmcPlace) { return (displace_From_(displace_From_(iz (lmcPlace)     , bounds(lmcPlace))), contents(lmcPlace) ) }
function absoluteDZplace   (lmcPlace) { return (displace_From_(displace_From_(dz (lmcPlace)     , bounds(lmcPlace))), contents(lmcPlace) ) }

function baseHeightForPlace_(lmcPlace) {
  y0     := snd(bounds(lmcPlace))
  posMBS := fst(mbs(lmcPlace))
  yM     := snd(posMBS)
  return (yM - y0 - 1)
}

function lmc_HeightForPlace_(lmc, lmcPlace) {
  return (lmc_MemHeigth(lmc)+baseHeightForPlace_(lmcPlace)+2) // 2 for the two walls
}

function lmc_WidthForPlace_(lmc, lmcPlace) {
  return (lmc_MemWidth(lmc)+2)                                // 2 for the two walls
}

//----------------------------------------------------------
// Drawing Operations
//----------------------------------------------------------
/*@ATTRIBUTE@block_name@Poner LMC_@*/
procedure PonerLMC_(lmc) {
  VaciarTablero()
  PonerLMC_WithRep_InPlace_(lmc, lmcRepresentation()
                               , LMCForm(lmcPlacementForMemWidth_(lmc_MemWidth(lmc)) | contents <- coordActual()))
}

procedure PonerLMC_WithRep_InPlace_(lmc, lmcRep, lmcPlace) {
  DibujarParedes  (lmc, lmcRep, lmcPlace)
  DibujarMemoria  (lmc, lmcRep, lmcPlace)
  DibujarElementos(lmc, lmcRep, lmcPlace)
  DibujarInput    (lmc, lmcRep, lmcPlace)
  DibujarOutput   (lmc, lmcRep, lmcPlace)
  DibujarLittleMan(lmc, lmcRep, lmcPlace)
}

function lmc_AsBoardWithRep_InPlace_(lmc, lmcRep, lmcPlace) {
  VaciarTablero()
  IrAlOrigen()
  PonerLMC_WithRep_InPlace_(lmc, lmcRep, lmcPlace)
  let (x,y) := memShapeOf_(bounds(lmc))
  return (tableroActualDe_x_(x,y))
}

//----------------------------------------------------------
// Drawing Main Parts
//----------------------------------------------------------
procedure DibujarParedes(lmc, lmcRep, lmcPlace) {
  /*
      OBSERVATION: the lmc final drawing depends on memory shape. 
                   Placement of elements must be according to that.
  */
  ancho := lmc_WidthForPlace_ (lmc,lmcPlace)
  alto  := lmc_HeigthForPlace_(lmc,lmcPlace)
  IrACoord_(absoluteBASEplace(lmcPlace))   // Base position is LowerLeft corner
  Mover__Veces(Norte,alto-1)               // But, it starts drawing from UpperLeft corner
  foreach dir in [Norte, Sur] {            // Each time, draw one L of the square
    DibujarLaEsquina_ParaRep_              (dir                    , lmcRep)
    DibujarParedRectaDeLongitud_Al_ParaRep_(ancho-2, dir           , lmcRep)
    DibujarLaEsquina_ParaRep_              (siguiente(dir)         , lmcRep)
    DibujarParedRectaDeLongitud_Al_ParaRep_(alto -2, siguiente(dir), lmcRep)
  }
}

procedure DibujarMemoria(lmc, lmcRep, lmcPlace) {
  IrACoord_(absoluteMBSplace(lmcPlace))
  foreach row in mbs(lmc) { 
    DibujarFilaDeMemoria_ParaRep_(row, lmcRep)
    Mover(Norte)
  } 
}

procedure DibujarElementos(lmc, lmcRep, lmcPlace) {
  PonerSlot_Towards_At_                  (inp(lmcRep), snd(inp(lmcPlace))           , absoluteINPplace(lmcPlace))
  PonerElemento_ConContenido_De_En_Desde_(pc (lmcRep), pc(lmc)              , lmcRep, absolutePCplace (lmcPlace) , absoluteINPplace(lmcPlace))
  PonerElemento_ConContenido_De_En_Desde_(acc(lmcRep), acc(lmc)             , lmcRep, absoluteACCplace(lmcPlace) , absolutePCplace (lmcPlace))
  PonerElemento_ConContenido_De_En_Desde_(neg(lmcRep), bool2num(neg(lmc))   , lmcRep, absoluteNEGplace(lmcPlace) , absoluteACCplace(lmcPlace))
  PonerElemento_ConContenido_De_En_Desde_(wz (lmcRep), numFromMaybe(wz(lmc)), lmcRep, absoluteWZplace (lmcPlace) , absoluteNEGplace(lmcPlace))
  PonerElemento_ConContenido_De_En_Desde_(iz (lmcRep), numFromMaybe(iz(lmc)), lmcRep, absoluteIZplace (lmcPlace) , absoluteWZplace (lmcPlace))
  PonerElemento_ConContenido_De_En_Desde_(dz (lmcRep), numFromMaybe(dz(lmc)), lmcRep, absoluteDZplace (lmcPlace) , absoluteIZplace (lmcPlace))
  PonerSlot_Towards_At_                  (out(lmcRep), snd(out(lmcPlace))           , absoluteOUTplace(lmcPlace))
}

procedure DibujarInput(lmc, lmcRep, lmcPlace) {
  IrACoord_(absoluteINPplace(lmcPlace))
  Poner_ElementosDeLaLista_ParaRep_ConElPrimeroHacia_(lmc_HeigthForPlace_(lmc,lmcPlace), inp(lmc)
                                                     ,lmcRep, opuesto(snd(inp(lmcPlace))))
}

procedure DibujarOutput(lmc, lmcRep, lmcPlace) {
  IrACoord_(absoluteOUTplace(lmcPlace))
  Poner_ElementosDeLaLista_ParaRep_ConElPrimeroHacia_(lmc_HeigthForPlace_(lmc,lmcPlace), out(lmc)
                                                     ,lmcRep, opuesto(snd(out(lmcPlace))))
}

procedure DibujarLittleMan(lmc, lmcRep, lmcPlace) {
  IrACoord_(absoluteLMplace(lmcPlace))
  PonerElemento_(choose halted_(lm(lmcRep)) when (lmc_IsHalted(lmc))
                        active_(lm(lmcRep)) otherwise)
}

//----------------------------------------------------------
// Operations to access the representation
//----------------------------------------------------------
procedure DibujarLaEsquina_ParaRep_(dir, lmcRep) {
  PonerElemento_(cornerWall_(bounds(lmcRep), dir))
  Mover(siguiente(dir))
}

procedure DibujarParedRectaDeLongitud_Al_ParaRep_(long, dir, lmcRep) {
  wallRep := straigthWall_(bounds(lmcRep), isHorizontal_(dir))
  repeat (long) {
    PonerElemento_(wallRep)
    Mover(siguiente(dir)) 
  } 
}

procedure DibujarFilaDeMemoria_ParaRep_(row, lmcRep) {
    foreach mb in row {
      PonerElemento_(mbs(lmcRep))  PonerContenido_(mb, lmcRep)
      Mover(Este)
    }
    foreach mb in row { Mover (Oeste) }  // Return the header to the starting cell
}

procedure PonerSlot_Towards_At_(elem, dir, coord) {
  IrACoord_(coord)
  Mover(dir)          PonerElemento_(elem)
  Mover(opuesto(dir)) PonerElemento_(elem)
}

procedure PonerElemento_ConContenido_De_En_Desde_(element, content, lmcRep, destino, origen) {
  IrACoord_Desde_(destino, origen)
  PonerElemento_(element)
  PonerContenido_(content, lmcRep)
}

procedure Poner_ElementosDeLaLista_ParaRep_ConElPrimeroHacia_(alto, lista, lmcRep, dir) {
  cantidadQueFaltan  := max(alto, length(lista))
  if (cantidadQueFaltan>0) {
    // The first element, on the slot
    PonerContenido_(primero(lista), lmcRep)
    Mover(opuesto(dir))
    Poner_ElementosDeLaLista_ParaRep_(cantidadQueFaltan-1, sinElPrimero(lista), lmcRep)
  }
}

procedure Poner_ElementosDeLaLista_ParaRep_(cantidad, lista, lmcRep) {
  if (cantidad>1) {
    // The border case
    PonerContenido_(primero(elementosQueFaltan), lmcRep)
    // The remaining elements
    cantidadQueFaltan := cantidad - 1
    elementosQueFaltan := sinElPrimero(lista)
    while (cantidadQueFaltan > 0) {
      Mover(Norte)
      PonerContenido_(primero(elementosQueFaltan), lmcRep)
      elementosQueFaltan := sinElPrimero(elementosQueFaltan)
    }
  }
}

procedure PonerContenido_(content, lmcRep) {
   PonerElemento_((colorDe_(contents(lmcRep))
                 , content
                 ))  
}

procedure PonerElemento_(elemRep) {
  let (color, value) := elemRep
  Poner__Veces(color, value)
}

function colorDe_(elemRep) {
  let (color, valor) := elemRep
  return (color)
}

function cantidadDe_(elemRep) {
  let (color, valor) := elemRep
  return (valor)
}

function halted_(lmRep) {
  let (color, valor) := lmRep
  return (color, primero(valor))
}

function active_(lmRep) {
  let (color, valor) := lmRep
  return (color, segundo(valor))
}

function straigthWall_(boundsRep, esVertical) {
  let (color, valor) := boundsRep
  return (color, choose primero(valor) when (esVertical) segundo(valor) otherwise)
}

function isHorizontal_(dir) { return (dir==Norte || dir==Sur) }

function cornerWall_(boundsRep, direction) {
  let (color, valor) := boundsRep
  return (color, elemAt_In_(corner2Index(direction), valor))
}

function corner2Index(dir) {
   return (matching (dir) select
             2 on Norte
             3 on Este
             4 on Sur
             5 otherwise
          )
}



//----------------------------------------------------------
// Operaciones auxiliares para lectura de LMC
//----------------------------------------------------------
function widthOfLMCMem() {
   IrAlOrigen()
   Mover(Este)
   widthSoFar := 0
   while (hayBolitas(Rojo) && puedeMover(Este)) {
      widthSoFar := widthSoFar + 1
      Mover(Este)
   }
   Assert(not hayBolitas(Rojo), "There is no LM room represented in the board -- no room for output")
   Assert(widthSoFar == 12, "There is no LM room represented in the board -- wrong width")
   return(widthSoFar - 2)
}

function depthOfLMCMem() {
   IrAlOrigen()
   Mover(Este)
   depthSoFar := 0
   while (hayBolitas(Rojo) && puedeMover(Norte)) {
      depthSoFar := depthSoFar + 1
      Mover(Norte)
   }
   if (hayBolitas(Rojo)) { depthSoFar := depthSoFar + 1 }
   Assert(depthSoFar > 4, "There is no LM room represented in the board -- wrong depth")
   return(depthSoFar - 4)
}

function sizeOfLMCMem() {
   IrAlOrigen()
   Mover__Veces(Este, 2)
   Mover__Veces(Norte, 3)
   sizeSoFar := 0
   while (hayBolitas(Negro)) {
      sizeSoFar := sizeSoFar + 1
      PasarAlSiguienteMB()
   }
   Assert(sizeSoFar > 1, "There is no LM room represented in the board -- wrong memory size")
   return(sizeSoFar )
}

procedure PasarAlSiguienteMB() {
  Mover(Este)  
  if (hayBolitas(Rojo))
    { IrAlBorde(Oeste)
      Mover__Veces(Este, 2)
      Mover(Norte)
    }
}
//===============================================================
//===============================================================
//==== LMC Model
//===============================================================
//===============================================================
// REQUIRES: GobstonesAmenities
// REQUIRES: GobstonesLists
// REQUIRES: LMCForm
// REQUIRES: LMCMem

//-------------------------------
//type LMCModel is LMCForm(
//      lm       -> Booleano
//    , pc       -> Número
//    , acc      -> Número
//    , neg      -> Booleano
//    , inp      -> Lista de Números
//    , out      -> Lista de Números
//    , mbs      -> Lista de Listas de Números
//    , bounds   -> (Número, Número)
//    , wz       -> Maybe(value -> Número)
//    , iz       -> Maybe(value -> Número)
//    , dz       -> Maybe(value -> Número)
//    , contents -> Número
//}
//-------------------------------

//-------------------------------
// LMC external operations
//-------------------------------
/*@ATTRIBUTE@block_name@empty LMC with mem size_@*/
function emptyLMCWithMemSize_AndWidth_(memSize, memWidth) {
  /* PURPOSE: describes a LMCForm of type LMCModel, with an empty configuration
     PRECONDITIONS:
       * memSize (the number of MailBoxeS) is <= 100
  */
  Assert(memSize <= 100, "Memory too big in emptyLMC -- it must be <= 100")
  let myBounds := (memSize, memWidth)
  return (LMCForm(lm       <- True                  // The Little Man starts active
                , pc       <- 0                     // The Program Counter in 0
                , acc      <- 0                     // The Accumulator also in 0
                , neg      <- False                 // No NEGatives results so far
                , inp      <- []                    // The INPut is initially empty
                , out      <- []                    // The OUTput is initially empty
                , mbs      <- emptyMemOf_(myBounds) // The MailBoxeS all in zero
                , bounds   <- myBounds              // The BOUNDS are the number of available mailboxes, and the width of a row
                , wz       <- Nothing               // The Working Zone is not set
                , iz       <- Nothing               // The Instruction Zone is not set
                , dz       <- Nothing               // The Data Zone is not set
                , contents <- 100                   // The base to separate instructions from data
         ))
}

function lmc_MemSize(lmc)   { return(fst(bounds(lmc)))              }
function lmc_MemWidth(lmc)  { return(snd(bounds(lmc)))              }
function lmc_MemHeigth(lmc) { return(snd(memShapeOf_(bounds(lmc)))) }

function loadInput_On_(input, lmc) {
  return (LMCForm (lmc | inp <- input))
}

function loadProgram_On_(prog, lmc) {
  let (size, width) := bounds(lmc)
  Assert(length(prog) <= size, "Program too big in loadProgram_On_ -- consider using a bigger memory")
  memWithProg := memOf_With_(bounds(lmc), prog)
  return (LMCForm (lmc | mbs <- memWithProg))
}

function execute_Program(lmc) {
  currentLMC := lmc
  while (not lmc_IsHalted(currentLMC)) {
    currentLMC := execute_ProgramOneStep(currentLMC)
  }
  return (currentLMC)
}

function debug_Program_Steps(lmc, cant) {
  incrementalExec := []
  foreach i in [0..cant] { incrementalExec := incrementalExec ++ [execute_Program_Steps(i,lmc) ] } 
  return (incrementalExec)
}

function execute_Program_Steps(lmc, cant) {
  currentLMC := lmc
  repeat (cant) { currentLMC := execute_ProgramOneStep(currentLMC) }
  return (currentLMC)
}

function execute_ProgramOneStep(lmc) {
  return(executeInstruction_      (
         incrementProgramCounter_(    // If this is done after executing the instruction, the PC is not right
         fetchData_             (
         decodeInstruction_    (
         fetchInstruction_(lmc)))))
        )                  
}

function inspectDebugFor_AtStep_(lmc, steps) {
    ds       := debug_Program_Steps(lmc,steps)
    lmcToSee := elemAt_In_(steps-1,ds)
    lmcToSee := fetchData_             (
         decodeInstruction_    (
         fetchInstruction_(lmcToSee)))
    dataAddr := decodeIndex_For_CalledBy_WhenDecoding_(value(wz(lmcToSee)) mod 100, bounds(lmcToSee), "inspectDebugFor_AtStep_", "WZ")
    return(value(wz(lmcToSee)), value(iz(lmcToSee))
          , dataAddr
          , fetchPos_From_(dataAddr, mbs(lmcToSee))
          , value(dz(lmcToSee))
          , lmcToSee)
}

//-------------------------------
// LMC Basics
//-------------------------------
function resetsInsLMC_(lmc) {
  return (LMCForm (lmc 
            | wz <- Nothing
            , iz <- Nothing
            , dz <- Nothing
         ))
}

function resetsPC_(lmc)    { return (LMCForm (lmc | pc  <- 0))     }
function setNegLMC_(lmc)   { return (LMCForm (lmc | neg <- True))  }
function clearNegLMC_(lmc) { return (LMCForm (lmc | neg <- False)) }
function lmc_IsHalted(lmc) { return(not lm(lmc))                   }

//-------------------------------
// LMC Instructions
//-------------------------------
function haltLMC_(lmc) { return (LMCForm (lmc | lm  <- False)) }

function addLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a ADD instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
     PARAMETERS: lmc is an LMCModel
  */
  res := acc(lmc) + value(dz(lmc))
  return (LMCForm (lmc 
            | acc <- res mod 100
            , neg <- (res div 100) /= 0
         ))
}

function subLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a SUB instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
  res := acc(lmc) - value(dz(lmc))
  return (LMCForm (lmc | acc <- res mod 100
                       , neg <- (res div 100) /= 0
        ))
}

function staLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a STA instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
  pos := decodeIndex_For_CalledBy_WhenDecoding_(value(dz(lmc)), bounds(lmc), "STA", "DZ")
  return (LMCForm (lmc |
            mbs <- setPos_To_InMem_(pos, acc(lmc), mbs(lmc))
         ))
}

function ldaLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a LDA instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
  pos := decodeIndex_For_CalledBy_WhenDecoding_(value(dz(lmc)), bounds(lmc), "LDA", "DZ")
  return (LMCForm (lmc | 
            acc <- fetchPos_From_(pos, mbs(lmc))
         ))
}

function braLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a BRA instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
  return (LMCForm (lmc | 
            pc <- value(dz(lmc))
         ))
}

function brzLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a BRZ instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
  return (LMCForm (lmc | 
            pc <- choose value(dz(lmc)) when (acc(lmc) == 0)
                         pc(lmc) otherwise
         ))
}

function brpLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a BRP instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
  return (LMCForm (lmc | 
            pc <- choose value(dz(lmc)) when (not neg(lmc))
                         pc(lmc) otherwise
         ))
}

function e_sLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a E/S instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
  return (choose 
            inputLMC_(lmc)     when (value(dz(lmc)) == 1)
            outputLMC_(lmc)    when (value(dz(lmc)) == 2)
            boom("Bad address in E/S instruction -- it must be either 1 or 2 (that is, insCode 901 o 902)") otherwise
         )
}

function inputLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a INP instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
     OBSERVATION: if the input is empty, inputs zeroes
  */
  if (esVacía(inp(lmc))) 
   then { let (val, newInp) := (0, inp(lmc)) }
   else { let (val, newInp) := (primero(inp(lmc)), sinElPrimero(inp(lmc))) }
   
  return (LMCForm (lmc | acc <- val, inp <- newInp))             
}

function outputLMC_(lmc) {
  /* PURPOSE: describes the lmc after executing a OUT instruction
     PRECONDITIONS: the LMC is not halted and the Data Zone is set
  */
return (LMCForm (lmc | out <- out(lmc) ++ [ acc(lmc) ]))             
}


//-------------------------------
// LMC inner working
//   (all functions assume as Inv.Rep. an lmc of type LMCModel)
//-------------------------------
function incrementProgramCounter_(lmc) {
  /* PURPOSE: describes the lmc after incrementing the Program Counter
     PRECONDITIONS: the LMC is not halted
  */
  let (size, width) := bounds(lmc)
  return (LMCForm (lmc | 
            pc <- (pc(lmc)+1) mod size
         ))
}

function fetchInstruction_(lmc) {
  /* PURPOSE: describes the lmc after setting the Working Zone according to the MailBox value given by the Program Counter
     PRECONDITIONS: the LMC is not halted
  */
  memPos := decodeIndex_For_CalledBy_WhenDecoding_(pc(lmc), bounds(lmc), "fetchInstruction_", "PC")
  return (LMCForm (lmc | 
            wz <- just(fetchPos_From_(memPos, mbs(lmc)))
         ))
}

function decodeInstruction_(lmc) {
  /* PURPOSE: describes the lmc after setting the Instruction Zone according to the opCode in the Working Zone
     PRECONDITIONS: the LMC is not halted and the Working Zone is set
  */
  insCode := value(wz(lmc)) div 100
  return (LMCForm(lmc | iz <- just(insCode)))
}

function fetchData_(lmc) {
  /* PURPOSE: describes the lmc after setting the Data Zone according to the data source of 
              the instruction in the Instruction Zone and the Working Zone
     PRECONDITIONS: the LMC is not halted and the Instruction Zone and Working Zone are set
  */
  insCode   := value(iz(lmc))
  dataIndex := value(wz(lmc)) mod 100
  dataAddr  := decodeIndex_For_CalledBy_WhenDecoding_(dataIndex, bounds(lmc), "fetchData_", "dataIndex of opCode")
  data      := fetchPos_From_(dataAddr, mbs(lmc))
  return (LMCForm(lmc | 
            dz <- dataAccordingToSourceFor_Between_And_(insCode, dataIndex, data)
         ))
}

function executeInstruction_(lmc) {
  /* PURPOSE: describes the lmc after executing the instruction given by the Instruction Zone
                (includes unsetting WZ, IZ and DZ as the last step)
     PRECONDITIONS: the LMC is not halted and the Instruction Zone and Data Zone are set
  */
  lmc' := matching (value(iz(lmc))) select
            haltLMC_(lmc) on 0
            addLMC_(lmc)  on 1
            subLMC_(lmc)  on 2
            staLMC_(lmc)  on 3
            ldaLMC_(lmc)  on 5
            braLMC_(lmc)  on 6
            brzLMC_(lmc)  on 7
            brpLMC_(lmc)  on 8
            e_sLMC_(lmc)  on 9
            boom("Instruction not recognized in executeInstruction -- review the program loaded") otherwise
  return (resetsInsLMC_(lmc'))
}  

//-------------------------------
// Auxiliaries for inner working
//-------------------------------
function dataAccordingToSourceFor_Between_And_(insCode, dataIdx, data) {
  return (choose just(data)    when (usesMem_(insCode))
                 just(dataIdx) when (usesValue_(insCode))
                 Nothing       otherwise
         )
}

function usesMem_(insCode) {
  /* PURPOSE: indicates if the given instruction uses a MailBox contents
     PRECONDITIONS: none
  */
  return (insCode == 1      // ADD uses MailBox content (to ADD it to the ACC)
       || insCode == 2      // SUB uses MailBox content (to SUBstructing from the ACC)
       || insCode == 5)     // LDA uses MailBox content (to LoaD to the ACC)
}

function usesValue_(insCode) {
  /* PURPOSE: indicates if the given instruction uses the opCode absolute value
     PRECONDITIONS: none
  */
  return (insCode == 3      // STA uses MailBox address  (to STore address value in the ACC)
       || insCode == 6      // BRA uses the opCode value (to set the PC)
       || insCode == 7      // BRZ uses the opCode value (to set the PC)
       || insCode == 8      // BRP uses the opCode value (to set the PC)
       || insCode == 9)
}
//===============================================================
//===============================================================
//==== LMC Memory representation
//===============================================================
//===============================================================
// REQUIRES: GobstonesAmenities
// REQUIRES: GobstonesLists

function memShapeOf_(bounds) {
  let (size, width) := bounds
  return (width, 1 + (size-1) div width)    
}
function memSizeOf_(memS)   { let (x,y) := memS; return (x*y) }

function emptyMemOf_(bounds) {
  let (size, width) := bounds
  let (x,y) := memShapeOf_(bounds)
  return (choose elem_Replicado_Veces(emptyRowOfSize_(x),y-1) ++ [ emptyRowOfSize_(size mod x) ] when (size mod x > 0)
                 elem_Replicado_Veces(emptyRowOfSize_(x),y)                                      otherwise
         )
}

function emptyRowOfSize_(size) { return (elem_Replicado_Veces(0,size)) }

function memOf_With_(bounds, prog) {
  let (size, width) := bounds
  let (x,y) := memShapeOf_(bounds)
  paddedProg := prog ++ elem_Replicado_Veces(0, size-length(prog))
  programToLoad := separate_InChunksOf_(paddedProg, x)
  return (programToLoad)
}

function decodeIndex_For_CalledBy_WhenDecoding_(index, bounds, caller, dataSource) {
  let (size, depth) := bounds
  Assert(index < size, "Out of memory bounds at ") // ++ caller ++ " decoding " ++ dataSource)
                                                               // Strings are not lists... :(
  let (x,y) := memShapeOf_(bounds)
  i := index mod x
  j := index div x
  return (i,j)
}

function fetchPos_From_(pos, mem) {
   let (i,j) := pos
   row := elemAt_In_(j, mem)
   return (elemAt_In_(i, row))
}

function setPos_To_InMem_(pos, val, mem) {
  let (i,j) := pos
  let (before, after) := splitList_At_(mem, j)
  row := primero (after)
  after := sinElPrimero (after)
  return (before
         ++ [ setIndex_To_InRow_(i,val,row) ]
         ++ after)
}

function setIndex_To_InRow_(idx, val, row) {
  let (before, after) := splitList_At_(row, idx)
  return (before
         ++ [ val ]
         ++ sinElPrimero(after))
}
//===============================================================
//===============================================================
//==== LMC basic Form for representation
//===============================================================
//===============================================================

type LMCForm is record {
  /* PURPOSE: Template for LMCs (can be used for model or viewRep)
  */
  field lm        // The Little Man 
  field pc        // The Program Counter
  field acc       // The Accumulator
  field neg       // The flag for NEGative results
  field inp       // The INPut
  field out       // The OUTput
  field mbs       // The MailBoxeS
  field bounds    // The BOUNDS (number of mailboxes, walls, etc.)
  field wz        // The Working Zone
  field iz        // The Instruction Zone
  field dz        // The Data Zone 
  field contents  // Information about CONTENTS (number limits, number representation)
}

//===============================================================
//===============================================================
//==== Gobstones Lists
//===============================================================
//===============================================================

function segundo(list)           { return (primero(sinElPrimero(list)))     }
function sinLosDosPrimeros(list) { return(sinElPrimero(sinElPrimero(list))) }

function length(list) { 
  elemSeenSoFar := 0
  foreach elem in list { elemSeenSoFar := elemSeenSoFar + 1 }
  return (elemSeenSoFar)
}

function elemAt_In_(idx, list) {
  current := list
  repeat(idx) { current := sinElPrimero(current) }
  return (primero(current))
}

function elem_Replicado_Veces(elem, cant) {
  new := []
  repeat(cant) { new := [ elem ] ++ new }
  return (new)
}

function splitList_At_(list, idx) {
  before := []
  after  := list
  pos    := 0
  while (pos<idx && not esVacía(after)) {
    before := before ++ [ primero(after) ]
    after  := sinElPrimero (after)
    pos := pos + 1
  }
  return (before, after)
}

function separate_InChunksOf_(list, size) {
  chunksSoFar     := []
  elementsToSplit := list
  while (not esVacía(elementsToSplit)) { 
   let (currentChunk, elementsToSplit) := splitList_At_(elementsToSplit, size)
   chunksSoFar := chunksSoFar ++ [ currentChunk ]
  }
  return (chunksSoFar)
}

function todasConcatenadas_(lists) {
  elementosVistos := []
  foreach list in lists {
    elementosVistos := elementosVistos ++ list
  }
  return(elementosVistos)
}

function combinadosDeAPares_Y_(list1, list2) {
  currentList1 := list1
  currentList2 := list2
  paresVistos := []
  while (not esVacía(currentList1) && not esVacía(currentList2)) {
    paresVistos := paresVistos ++ [ (primero(currentList1), primero(currentList2)) ]
    currentList1 := sinElPrimero(currentList1)
    currentList2 := sinElPrimero(currentList2)
  }
  return (paresVistos)
}
//===============================================================
//===============================================================
//==== Gobstones Amenities
//===============================================================
//===============================================================

//-------------------------------
// Maybe functions
//-------------------------------
type Maybe is variant {
  case Nothing {}
  case Just    { field value }
}

function just(val) { return (Just(value <- val)) }
function numFromMaybe(maybeNum) {
  return (matching (maybeNum) select
            value(maybeNum) on Just
            0               otherwise
         )
}

function bool2num(b) { return (choose 1 when (b) 0 otherwise) }

function fst(par) {
  let (a,b) := par
  return (a)
}

function snd(par) {
  let (a,b) := par
  return (b)
}

function max(a,b) {
  return (choose a when (a>b) 
                 b otherwise)
}

//-------------------------------
// Basic Gobstones functions
//-------------------------------
procedure Assert (cond, msg) { if (not cond) { BOOM(msg) } }

/*@ATTRIBUTE@atomic@*/
procedure Poner__Veces(color,     cantidad) { repeat (cantidad) { Poner(color)     } }
/*@ATTRIBUTE@atomic@*/
procedure Sacar__Veces(color,     cantidad) { repeat (cantidad) { Sacar(color)     } }
/*@ATTRIBUTE@atomic@*/
procedure Mover__Veces(dirección, cantidad) { repeat (cantidad) { Mover(dirección) } }

procedure MoverHacia__Veces(dirección, cantidad) {
  if (cantidad >= 0) 
       { Mover__Veces(dirección         , cantidad)          }
  else { Mover__Veces(opuesto(dirección), opuesto(cantidad)) }
}

procedure IrAlOrigen() { IrAlBorde(Sur) IrAlBorde(Oeste) }
procedure PasarASiguienteCelda() {
    if (puedeMover(Este)) { Mover(Este) }
    else { IrAlBorde(Oeste) Mover(Norte) }
}

function coordActual() {
  return(distanciaAlBorde_(Oeste), distanciaAlBorde_(Sur))
}

procedure IrACoord_(coord) {
  let (x,y) := coord
  IrAlOrigen()
  Mover__Veces(Este , x)
  Mover__Veces(Norte, y)
}

procedure IrACoord_Desde_(coordDestino, coordActual) {
  let (x0,y0) := coordActual
  let (x1,y1) := coordDestino
  MoverHacia__Veces(Este , x1-x0)
  MoverHacia__Veces(Norte, y1-y0)
}

function displace_From_(offset, baseCoord) {
  let (dx,dy) := offset
  let (x ,y ) := baseCoord
  return (x+dx, y+dy)
}

function distanciaAlBorde_(dir) {
  pasosDados := 0
  while (puedeMover(dir)) { pasosDados := pasosDados + 1 }
  return (pasosDados)
}

//----------------------------------------------------------
// Reading and writing of the board
//----------------------------------------------------------
function tableroActualDe_x_(ancho, alto) {
  IrAlOrigen()
  tablero := [ filaActualDeAncho_(ancho) ]
  repeat (alto-1) {
    Mover(Norte)
    tablero := [ filaActualDeAncho_(ancho) ] ++ tablero
    
  }
  return (tablero)
}

procedure PonerTablero_(tablero) {
    VaciarTablero()
    IrAlOrigen()
    Mover__Veces(Norte, length(tablero))
    PonerFila_(primero(tablero))
    foreach fila in (sinElPrimero(tablero)) {
        Mover(Sur)
        PonerFila_(fila)
    }
}

function filaActualDeAncho_(ancho) {
  IrAlBorde(Oeste)
  fila := [ celdaActual() ]
  repeat (ancho-1) {
    Mover(Este)
    fila := fila ++ [ celdaActual() ]
  }
  return (fila)
}

procedure PonerFila_(fila) {
    IrAlBorde(Oeste)
    PonerCelda_(primero(fila))
    foreach celda in (sinElPrimero(fila)) {
        Mover(Este)
        PonerCelda_(celda)
    }
}

function celdaActual() {
   return (nroBolitas(Azul), nroBolitas(Negro)
         , nroBolitas(Rojo), nroBolitas(Verde))
}

procedure PonerCelda_(celda) {
    let (azul, negro, rojo, verde) := celda
    Poner__Veces(Azul , azul )
    Poner__Veces(Negro, negro)
    Poner__Veces(Rojo , rojo )
    Poner__Veces(Verde, verde)
}

