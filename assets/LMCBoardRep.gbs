//===============================================================
//===============================================================
//==== LMC Board Representation
//===============================================================
//===============================================================
// REQUIRES: GobstonesAmenities
// REQUIRES: GobstonesLists
// REQUIRES: LMCForm
// REQUIRES: LMCMem
// REQUIRES: LMCModel

// program {
//   lmc := loadInput_On_([10,20,30],
//          loadProgram_On_([901, 902],
//          emptyLMCWithMemSize_(20)
//          ))
//   PonerLMC_WithRep_InPlace_( lmc
//                            , lmcRepresentation()
//                            , lmcPlacement())
// }

//----------------------------------------------------------
// LMC's Board Representation 
//----------------------------------------------------------
//type LMCBoardRep is LMCForm(
//      lm       -> (Color, Lista de Números)
//    , pc       -> (Color, Número)
//    , acc      -> (Color, Número)
//    , neg      -> (Color, Número)
//    , inp      -> (Color, Número)
//    , out      -> (Color, Número)
//    , mbs      -> (Color, Número)
//    , bounds   -> (Color, Lista de Números)
//    , wz       -> (Color, Número)
//    , iz       -> (Color, Número)
//    , dz       -> (Color, Número)
//    , contents -> (Color, Número)
//}

//----------------------------------------------------------
// LMC's Board Placement
//----------------------------------------------------------
//type Coord is (Número, Número)
//type LMCBoardPlace is LMCForm(
//      lm       -> Coord               // Relative to bounds
//    , pc       -> Coord               // Relative to bounds
//    , acc      -> Coord               // Relative to bounds
//    , neg      -> Coord               // Relative to bounds
//    , inp      -> (Coord, Dirección)  // Base coord, dir of second coord, relative to bounds
//    , out      -> (Coord, Dirección)  // Base coord, dir of second coord, relative to bounds
//    , mbs      -> (Coord, Número)     // LowerLeft corner, relative to bounds
//    , bounds   -> Coord               // LowerLeft corner, absolute
//    , wz       -> Coord               // Relative to bounds
//    , iz       -> Coord               // Relative to bounds
//    , dz       -> Coord               // Relative to bounds
//    , contents -> Coord               // Current position, relative (ideally, the same of LM)
//}

//----------------------------------------------------------
function lmcRepresentation() {
   /* PURPOSE: describes a LMCForm of type LMCBoardRep, with a representation of an LMC
      PRECONDITIONS: none
  */
  return (LMCForm(lm       <- (Verde, [ 11, 1 ])      // The Little Man representation (Halted, Active)
                , pc       <- (Negro, 10)             // The Program Counter place representation
                , acc      <- (Negro, 11)             // The Accumulator place representation
                , neg      <- (Negro, 12)             // The NEGative flag place representation
                , inp      <- (Negro,  2)             // The INPut place representation
                , out      <- (Negro,  3)             // The OUTput place representation
                , mbs      <- (Negro,  1)             // The MailBoxeS places representation
                , bounds   <- (Rojo , [1,2,3,4,5,6])  // The BOUNDS are walls representation (Vertical, Horizontal, NO, NE, SO, SE)
                , wz       <- (Negro, 20)             // The Working Zone place representation
                , iz       <- (Negro, 21)             // The Instruction Zone place representation
                , dz       <- (Negro, 22)             // The Data Zone place representation
                , contents <- (Azul ,  0)             // The numeric CONTENTS of mailboxes; any number will do
         ))
}

//----------------------------------------------------------
function lmcPlacement() {
   /* PURPOSE: describes a LMCForm of type LMCBoardPlace, with the absolute positions of elements in an LMC
      PRECONDITIONS: none
      OBSERVATION: the lmc final drawing depends on memory shape. 
                   Walls surround the memory Mailboxes tightly.
                   Placement of elements must be according to that, on the base.
                   (Usually, at the base -- see function baseHeight)
                        . /==========\.
                        . |mmmmmmmmmm|.
                        . |mmmmmmmmmm|.  Memory
                        . |mmmmmmmmmm|.
                        . |  l       |.  Base
                        . i  panwid  o.    (Elements -- at the base)
                          \==========/
   */
  return (LMCForm(lm       <-  ( 3,2)         // The Little Man place position
                , pc       <-  ( 3,1)         // The Program Counter place position
                , acc      <-  ( 4,1)         // The Accumulator place position
                , neg      <-  ( 5,1)         // The NEGative flag place position
                , inp      <- (( 0,1), Oeste) // The INPut place position, and where to continue
                , out      <- ((11,1), Este)  // The OUTput place position, and where to continue
                , mbs      <- (( 1,3), 10)    // The MailBoxeS left corner position and width
                , bounds   <-  ( 1,0)         // The BOUNDS walls left corner place position (absolute)
                , wz       <-  ( 6,1)         // The Working Zone place position
                , iz       <-  ( 7,1)         // The Instruction Zone place position
                , dz       <-  ( 8,1)         // The Data Zone place position
                , contents <-  ( 3,2)         // The current place position
         ))
}

function absoluteBASEplace (lmcPlace) { return (bounds(lmcPlace)) }
function absoluteLMplace   (lmcPlace) { return (displace_From_(lm (lmcPlace)     , bounds(lmcPlace))) }
function absolutePCplace   (lmcPlace) { return (displace_From_(pc (lmcPlace)     , bounds(lmcPlace))) }
function absoluteACCplace  (lmcPlace) { return (displace_From_(acc(lmcPlace)     , bounds(lmcPlace))) }
function absoluteNEGplace  (lmcPlace) { return (displace_From_(neg(lmcPlace)     , bounds(lmcPlace))) }
function absoluteINPplace  (lmcPlace) { return (displace_From_(fst(inp(lmcPlace)), bounds(lmcPlace))) }
function absoluteOUTplace  (lmcPlace) { return (displace_From_(fst(out(lmcPlace)), bounds(lmcPlace))) }
function absoluteMBSplace  (lmcPlace) { return (displace_From_(fst(mbs(lmcPlace)), bounds(lmcPlace))) }
function absoluteWZplace   (lmcPlace) { return (displace_From_(wz (lmcPlace)     , bounds(lmcPlace))) }
function absoluteIZplace   (lmcPlace) { return (displace_From_(iz (lmcPlace)     , bounds(lmcPlace))) }
function absoluteDZplace   (lmcPlace) { return (displace_From_(dz (lmcPlace)     , bounds(lmcPlace))) }

//----------------------------------------------------------
// Drawing Operations
//----------------------------------------------------------
/*@ATTRIBUTE@block_name@Poner LMC_@*/
procedure PonerLMC_(lmc) {
  VaciarTablero()
  PonerLMC_WithRep_InPlace_(lmc, lmcRepresentation(), lmcPlacement())
}

procedure PonerLMC_WithRep_InPlace_(lmc, lmcRep, lmcPlace) {
  DibujarParedes  (lmc, lmcRep, lmcPlace)
  DibujarMemoria  (lmc, lmcRep, lmcPlace)
  DibujarElementos(lmc, lmcRep, lmcPlace)
  DibujarInput    (lmc, lmcRep, lmcPlace)
  DibujarOutput   (lmc, lmcRep, lmcPlace)
  DibujarLittleMan(lmc, lmcRep, lmcPlace)
}

function lmc_AsBoardWithRep_InPlace_(lmc, lmcRep, lmcPlace) {
  VaciarTablero()
  PonerLMC_WithRep_InPlace_(lmc, lmcRep, lmcPlace)
  let (x,y) := memShapeOf_(bounds(lmc))
  return (tableroActualDe_X_(x,y))
}

//----------------------------------------------------------
// Drawing Main Parts
//----------------------------------------------------------
procedure DibujarParedes(lmc, lmcRep, lmcPlace) {
  /*
      OBSERVATION: the lmc final drawing depends on memory shape. 
                   Placement of elements must be according to that.
  */
  let (ancho,alto) := memShapeOf_(bounds(lmc))
  IrACoord_(absoluteBASEplace(lmcPlace))                   // Base position is LowerLeft corner
  Mover__Veces(Norte,wallHeightOf_For_(alto, lmcPlace)-1)  // But, it starts drawing from UpperLeft corner
  foreach dir in [Norte, Sur] {
    DibujarCornerDel_Para_(dir, lmcRep)
    DibujarStraightWallDel_DeAncho_Para_(dir, ancho, lmcRep)
    DibujarCornerDel_Para_(siguiente(dir), lmcRep)
    DibujarStraightWallDel_DeAncho_Para_(siguiente(dir), alto+2   , lmcRep)
  }
}

procedure DibujarMemoria(lmc, lmcRep, lmcPlace) {
  let (ancho,alto) := memShapeOf_(bounds(lmc))
  IrACoord_(absoluteMBSplace(lmcPlace))
  foreach row in mbs(lmc) { 
    DibujarFilaDeMemoria(row, lmcRep)
    Mover(Norte)
  } 
}

procedure DibujarElementos(lmc, lmcRep, lmcPlace) {
  let (size, width) := bounds(lmc)
  let (ancho,alto ) := memShapeOf_(bounds(lmc))
  emptyCell := (colorDe_(pc(lmcRep)), 0)
  elemsContainers := [ inp(lmcRep)          , inp(lmcRep)
                     , emptyCell            , emptyCell
                     , pc(lmcRep)           , acc(lmcRep)          , neg(lmcRep)
                     , wz(lmcRep)           , iz(lmcRep)           , dz(lmcRep)
                     , emptyCell            , emptyCell
                     , out(lmcRep)          , out(lmcRep)
                     ]
  elemsContents   := [ 0                    , 0
                     , 0                    , 0
                     , pc(lmc)              , acc(lmc)             , bool2num(neg(lmc))
                     , numFromMaybe(wz(lmc)), numFromMaybe(iz(lmc)), numFromMaybe(dz(lmc))
                     , 0                    , 0
                     , 0                    , 0
                     ]
  elems := combinadosDeAPares_Y_(elemsContainers, elemsContents) 
  IrAlOrigen() Mover(Norte)
  PonerElementoYContenido_De_(primero(elems), lmcRep)
  foreach elementYContent in sinElPrimero(elems) {
    Mover(Este)
    PonerElementoYContenido_De_(elementYContent, lmcRep)
  }
}

procedure DibujarInput(lmc, lmcRep, lmcPlace) {
  let (ancho,alto) := memShapeOf_(bounds(lmc))
  IrAlOrigen()
  Mover(Norte)
  Poner_ElementosDeLaLista_Para_ConElPrimeroHacia_(wallHeightOf_For_(alto,lmcPlace), inp(lmc), lmcRep, Este)
}

procedure DibujarOutput(lmc, lmcRep, lmcPlace) {
  let (ancho,alto) := memShapeOf_(bounds(lmc))
  IrAlOrigen()
  Mover(Este) while (hayBolitas(colorDe_(bounds(lmcRep)))) { Mover(Este) }
  Mover(Norte)
  Poner_ElementosDeLaLista_Para_ConElPrimeroHacia_(wallHeightOf_For_(alto,lmcPlace), out(lmc), lmcRep, Oeste)
}

procedure DibujarLittleMan(lmc, lmcRep, lmcPlace) {
  IrAlOrigen() Mover__Veces(Norte, 2)
  Mover__Veces(Este, 4)
  PonerElemento_(choose halted_(lm(lmcRep)) when (lmc_IsHalted(lmc))
                        active_(lm(lmcRep)) otherwise)
}

//----------------------------------------------------------
// Operations to access the representation
//----------------------------------------------------------
function baseHeightFor_(lmcPlace) {
  let (x0,y0)           := bounds(lmcPlace)
  let (posMBS,memWidth) := mbs(lmcPlace)
  let (xM,yM)           := posMBS
  return (yM - y0 - 1)
}

function wallHeightOf_For_(alto, lmcPlace) {
  return (alto+baseHeightFor_(lmcPlace)+2)
}

procedure DibujarCornerDel_Para_(dir, lmcRep) {
  PonerElemento_(cornerWall_(bounds(lmcRep), dir))
  Mover(siguiente(dir))
}

procedure DibujarStraightWallDel_DeAncho_Para_(dir, ancho, lmcRep) {
  wallRep := straigthWall_(bounds(lmcRep), isHorizontal_(dir))
  repeat (ancho) {
    PonerElemento_(wallRep)
    Mover(siguiente(dir)) 
  } 
}

procedure DibujarFilaDeMemoria(row, lmcRep) {
    foreach mb in row {
      PonerElemento_(mbs(lmcRep))  PonerContenido_(mb, lmcRep)
      Mover(Este)
    }
    foreach mb in row { Mover (Oeste) }  // Return the header to the starting cell
}

procedure Poner_ElementosDeLaLista_Para_ConElPrimeroHacia_(alto, lista, lmcRep, dir) {
  elementosQueFaltan := combinadosDeAPares_Y_(lista, [1..alto])
  if (not esVacía(elementosQueFaltan)) {
    // The first element, on the slot
    Mover(dir) PonerContenido_(fst(primero(elementosQueFaltan)), lmcRep) Mover(opuesto(dir))
    // The second element, alone, as a border case
    elementosQueFaltan := sinElPrimero(elementosQueFaltan)
    PonerContenido_(fst(primero(elementosQueFaltan)), lmcRep)
    // The remaining elements
    foreach contentConIndex in sinElPrimero(elementosQueFaltan) {
      Mover(Norte)
      PonerContenido_(fst(contentConIndex), lmcRep)
  }}
}

procedure PonerElementoYContenido_De_(elementYContent, lmcRep) {
  let (element, content) := elementYContent
  PonerElemento_(element)
  PonerContenido_(content, lmcRep)
}

procedure PonerContenido_(content, lmcRep) {
   PonerElemento_((colorDe_(contents(lmcRep))
                 , content
                 ))  
}

procedure PonerElemento_(elemRep) {
  let (color, value) := elemRep
  Poner__Veces(color, value)
}

function colorDe_(elemRep) {
  let (color, valor) := elemRep
  return (color)
}

function cantidadDe_(elemRep) {
  let (color, valor) := elemRep
  return (valor)
}

function halted_(lmRep) {
  let (color, valor) := lmRep
  return (color, primero(valor))
}

function active_(lmRep) {
  let (color, valor) := lmRep
  return (color, segundo(valor))
}

function straigthWall_(boundsRep, esVertical) {
  let (color, valor) := boundsRep
  return (color, choose primero(valor) when (esVertical) segundo(valor) otherwise)
}

function isHorizontal_(dir) { return (dir==Norte || dir==Sur) }

function cornerWall_(boundsRep, direction) {
  let (color, valor) := boundsRep
  return (color, elemAt_In_(corner2Index(direction), valor))
}

function corner2Index(dir) {
   return (matching (dir) select
             2 on Norte
             3 on Este
             4 on Sur
             5 otherwise
          )
}



//----------------------------------------------------------
// Operaciones auxiliares para lectura de LMC
//----------------------------------------------------------
function widthOfLMCMem() {
   IrAlOrigen()
   Mover(Este)
   widthSoFar := 0
   while (hayBolitas(Rojo) && puedeMover(Este)) {
      widthSoFar := widthSoFar + 1
      Mover(Este)
   }
   Assert(not hayBolitas(Rojo), "There is no LM room represented in the board -- no room for output")
   Assert(widthSoFar == 12, "There is no LM room represented in the board -- wrong width")
   return(widthSoFar - 2)
}

function depthOfLMCMem() {
   IrAlOrigen()
   Mover(Este)
   depthSoFar := 0
   while (hayBolitas(Rojo) && puedeMover(Norte)) {
      depthSoFar := depthSoFar + 1
      Mover(Norte)
   }
   if (hayBolitas(Rojo)) { depthSoFar := depthSoFar + 1 }
   Assert(depthSoFar > 4, "There is no LM room represented in the board -- wrong depth")
   return(depthSoFar - 4)
}

function sizeOfLMCMem() {
   IrAlOrigen()
   Mover__Veces(Este, 2)
   Mover__Veces(Norte, 3)
   sizeSoFar := 0
   while (hayBolitas(Negro)) {
      sizeSoFar := sizeSoFar + 1
      PasarAlSiguienteMB()
   }
   Assert(sizeSoFar > 1, "There is no LM room represented in the board -- wrong memory size")
   return(sizeSoFar )
}

