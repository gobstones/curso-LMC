//===============================================================
//===============================================================
//==== Gobstones Amenities
//===============================================================
//===============================================================

//-------------------------------
// Maybe functions
//-------------------------------
type Maybe is variant {
  case Nothing {}
  case Just    { field value }
}

function just(val) { return (Just(value <- val)) }
function numFromMaybe(maybeNum) {
  return (matching (maybeNum) select
            value(maybeNum) on Just
            0               otherwise
         )
}

function bool2num(b) { return (choose 1 when (b) 0 otherwise) }

function fst(par) {
  let (a,b) := par
  return (a)
}

function snd(par) {
  let (a,b) := par
  return (b)
}

function max(a,b) {
  return (choose a when (a>b) 
                 b otherwise)
}

function min(a,b) {
  return (choose a when (a<b) 
                 b otherwise)
}

//-------------------------------
// Basic Gobstones functions
//-------------------------------
procedure Assert_OrFailWith_(cond, msg) { if (not cond) { BOOM(msg) } }

/*@ATTRIBUTE@atomic@*/
procedure Poner__Veces(color,     cantidad) { repeat (cantidad) { Poner(color)     } }
/*@ATTRIBUTE@atomic@*/
procedure Sacar__Veces(color,     cantidad) { repeat (cantidad) { Sacar(color)     } }
/*@ATTRIBUTE@atomic@*/
procedure Mover__Veces(dirección, cantidad) { repeat (cantidad) { Mover(dirección) } }

/*@ATTRIBUTE@atomic@*/
procedure MoverHacia__Veces(dirección, cantidad) {
  if (cantidad >= 0) 
       { Mover__Veces(dirección         , cantidad)          }
  else { Mover__Veces(opuesto(dirección), opuesto(cantidad)) }
}

//-------------------------------
// Gobstones positioning
//-------------------------------
/*@ATTRIBUTE@atomic@*/
procedure IrAlOrigen() { IrAlBorde(Sur) IrAlBorde(Oeste) }
/*@ATTRIBUTE@atomic@*/
procedure PasarASiguienteCelda() {
    if (puedeMover(Este)) { Mover(Este) }
    else { IrAlBorde(Oeste) Mover(Norte) }
}

function coordActual() {
  return(distanciaAlBorde_(Oeste), distanciaAlBorde_(Sur))
}

/*@ATTRIBUTE@atomic@*/
procedure IrACoord_(coord) {
  let (x,y) := coord
  IrAlOrigen()
  Mover__Veces(Este , x)
  Mover__Veces(Norte, y)
}

/*@ATTRIBUTE@atomic@*/
procedure IrACoord_Desde_(coordDestino, coordActual) {
  let (x0,y0) := coordActual
  let (x1,y1) := coordDestino
  MoverHacia__Veces(Este , x1-x0)
  MoverHacia__Veces(Norte, y1-y0)
}

function displace_From_(offset, baseCoord) {
  let (dx,dy) := offset
  let (x ,y ) := baseCoord
  return (x+dx, y+dy)
}

function distanciaAlBorde_(dir) {
  pasosDados := 0
  while (puedeMover(dir)) { 
    pasosDados := pasosDados + 1
    Mover(dir)
  }
  return (pasosDados)
}

//----------------------------------------------------------
// Reading and writing of the board
//----------------------------------------------------------
function tableroActualDe_x_(ancho, alto) {
  IrAlOrigen()
  tablero := [ filaActualDeAncho_(ancho) ]
  repeat (alto-1) {
    Mover(Norte)
    tablero := [ filaActualDeAncho_(ancho) ] ++ tablero
    
  }
  return (tablero)
}

procedure PonerTablero_(tablero) {
    VaciarTablero()
    IrAlOrigen()
    Mover__Veces(Norte, length(tablero))
    PonerFila_(primero(tablero))
    foreach fila in (sinElPrimero(tablero)) {
        Mover(Sur)
        PonerFila_(fila)
    }
}

function filaActualDeAncho_(ancho) {
  IrAlBorde(Oeste)
  fila := [ celdaActual() ]
  repeat (ancho-1) {
    Mover(Este)
    fila := fila ++ [ celdaActual() ]
  }
  return (fila)
}

procedure PonerFila_(fila) {
    IrAlBorde(Oeste)
    PonerCelda_(primero(fila))
    foreach celda in (sinElPrimero(fila)) {
        Mover(Este)
        PonerCelda_(celda)
    }
}

function celdaActual() {
   return (nroBolitas(Azul), nroBolitas(Negro)
         , nroBolitas(Rojo), nroBolitas(Verde))
}

/*@ATTRIBUTE@atomic@*/
procedure PonerCelda_(celda) {
    let (azul, negro, rojo, verde) := celda
    Poner__Veces(Azul , azul )
    Poner__Veces(Negro, negro)
    Poner__Veces(Rojo , rojo )
    Poner__Veces(Verde, verde)
}

